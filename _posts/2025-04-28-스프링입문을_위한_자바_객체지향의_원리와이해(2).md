---
layout: post
title: 스프링입문을위한 자바 객체지향의 원리와 이해(2)
date: 2025-04-28
categories: [CS, OOP, SWE,BookReview]
tags: [Java]
---

# 3. 객체지향과 Java
[이전 포스팅-스프링입문을위한 자바 객체지향의 원리와 이해(1)](https://younghoney.github.io/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EC%9E%85%EB%AC%B8%EC%9D%84_%EC%9C%84%ED%95%9C_%EC%9E%90%EB%B0%94_%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98_%EC%9B%90%EB%A6%AC%EC%99%80%EC%9D%B4%ED%95%B4/)

에서는 왜 객체지향이고 왜 Java인지 간단히 살펴봤다. 이번 포스팅에서는 **객체지향프로그래밍**에 대해 더 자세히 살펴보자.

## 3.1 객체지향의 4대 특성

1. **캡슐화 (Encapsulation)**  
   - 데이터와 메서드를 하나의 객체로 묶어 외부로부터 내부 구현을 숨긴다.
   - 정보를 보호하고, 시스템의 복잡도를 줄인다.

   👉 **예시: public, private 같은 접근제어자 사용**

2. **상속 (Inheritance)**  
   - 기존 클래스(부모 클래스)의 특성과 기능을 새로운 클래스(자식 클래스)가 재사용하고 확장할 수 있게 한다.
   - 코드 재사용성과 유지보수성을 높인다.
   
    👉 **예시: extends, implements**
3. **추상화 (Abstraction)**  
   - 복잡한 현실 세계를 필요한 부분만 골라 모델링한다.
   - 객체의 핵심적인 부분만 외부에 드러내고, 불필요한 세부사항은 감춘다.

    👉 **예시: class와 객체**

4. **다형성 (Polymorphism)**  
   - 하나의 인터페이스로 여러 다른 형태의 객체를 다룰 수 있게 한다.
   - 코드의 유연성과 확장성을 높여준다.
   
   👉 **예시: 오버로딩과 오버라이딩**

<br><br><br><br>

## 3-2. 캡슐화 자세히 살펴보기

### ✏️ 캡슐화란?

**캡슐화(Encapsulation)**는  
- 데이터(속성)와 데이터를 다루는 메서드(동작)를 하나의 객체 안에 묶고,  
- 외부에서 직접 데이터에 접근하지 못하도록 막는 것을 의미한다.

즉, **객체 내부의 복잡한 로직은 숨기고**,  
**외부에는 꼭 필요한 기능만 공개**하는 것이다.

---

### 📚 왜 캡슐화가 필요한가?

1. **데이터 보호(Data Protection)**  
   - 중요한 데이터가 외부에서 무분별하게 수정되는 것을 막을 수 있다.
   
2. **코드 유지보수성 향상(Maintainability)**  
   - 내부 구현을 수정해도 외부에는 영향이 없으므로, 유지보수가 쉬워진다.

3. **프로그램의 복잡도 감소(Reduction of Complexity)**  
   - 객체가 스스로 자신의 상태를 책임지기 때문에 시스템이 더 이해하기 쉬워진다.

---

### ✏️ Java에서 캡슐화 구현 방법

**1. 접근 제어자 사용 (Access Modifiers)**  
Java는 접근 제어자를 통해 멤버(변수, 메서드)의 공개 범위를 설정한다.

| 접근 제어자 | 설명 |
|:---|:---|
| `private` | 같은 클래스 내부에서만 접근 가능 (가장 엄격) |
| `default` (package-private) | 같은 패키지 내에서 접근 가능 |
| `protected` | 같은 패키지 + 다른 패키지의 자식 클래스에서 접근 가능 |
| `public` | 어디서든 접근 가능 (가장 개방적) |

**2. Getter와 Setter 메서드 제공**  
직접 변수에 접근하지 않고, 메서드를 통해 간접적으로 데이터를 읽거나 수정한다.

---

### 📚 예시: Java에서의 캡슐화

```java
public class Car {
    private int speed;  // 외부에서 직접 접근 불가

    public int getSpeed() {  // 데이터 읽기 (Getter)
        return speed;
    }

    public void accelerate() {  // 데이터 변경 (Setter 역할)
        speed += 10;
    }

    public void brake() {
        if (speed >= 10)
            speed -= 10;
    }
}
